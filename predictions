def prepare_historical_features(df_hist):
    """Prepare historical data with all rolling features"""
    df = df_hist.copy()
    df['dispatch_month'] = pd.to_datetime(df['dispatch_month']).dt.to_period('M')
    df['cpu'] = df['cost'] / df['volume']
    
    # Calculate rolling features
    grp = df.groupby(['plant', 'model', 'dispatch_month'])
    
    df['cpu_ema6'] = grp['cpu'].apply(lambda s: s.ewm(span=SPAN, adjust=False).mean())
    df['cpu_roll_mean6'] = grp['cpu'].apply(lambda s: s.rolling(WIN, min_periods=1).mean())
    df['cpu_roll_std6'] = grp['cpu'].apply(lambda s: s.rolling(WIN, min_periods=2).std())
    df['cpu_lag1'] = grp['cpu'].shift(1)
    df['cpu_pctchg1'] = grp['cpu'].pct_change()
    
    # Handle infinities and NaNs
    df['cpu_pctchg1'].replace([np.inf, -np.inf], np.nan, inplace=True)
    df[FEATURE_COLS] = df.groupby(['plant', 'model', 'dispatch_month'])[FEATURE_COLS].ffill()
    
    return df

def create_prediction_grid_for_month(master_df, forecast_month):
    """Create prediction grid for a specific forecast month"""
    forecast_period = pd.Period(forecast_month, freq='M')
    cutoff_dispatch = forecast_period - (MAX_AGE - 1)
    
    # Get unique cohorts
    cohorts = (
        master_df.loc[master_df['dispatch_month'].between(cutoff_dispatch, forecast_period)]
        [['plant', 'model', 'dispatch_month', 'volume']].drop_duplicates()
    )
    
    if cohorts.empty:
        return pd.DataFrame()
    
    # Calculate age each cohort will be in forecast month
    cohorts['age'] = (forecast_period - cohorts['dispatch_month']).apply(lambda x: x.n)
    
    # Keep only valid ages (1-60)
    cohorts = cohorts.query('1 <= age <= @MAX_AGE').copy()
    cohorts['forecast_month'] = forecast_period
    cohorts['warranty_month'] = forecast_period
    
    return cohorts

print("✅ Data preparation functions defined")




def attach_features_to_grid(pred_grid, master_df):
    """Attach rolling features to prediction grid"""
    if pred_grid.empty:
        return pred_grid
    
    # Merge with latest available features
    feature_data = master_df[['plant', 'model', 'dispatch_month', 'age'] + FEATURE_COLS]
    
    pred_grid = pred_grid.merge(
        feature_data,
        on=['plant', 'model', 'dispatch_month', 'age'],
        how='left'
    )
    
    # Forward-fill features within each cohort for missing ages
    pred_grid[FEATURE_COLS] = (
        pred_grid.groupby(['plant', 'model', 'dispatch_month'])[FEATURE_COLS].ffill()
    )
    
    # Add calendar features
    pred_grid['dispatch_month_num'] = pred_grid['dispatch_month'].astype(int)
    
    return pred_grid

def make_predictions(pred_grid, model):
    """Generate CPU and cost predictions"""
    if pred_grid.empty:
        return pred_grid
    
    # Ensure all required features are present
    X = pred_grid[MODEL_FEATURES]
    
    # Predict CPU
    pred_grid['cpu_hat'] = model.predict(X)
    
    # Convert to total cost
    pred_grid['cost_hat'] = pred_grid['cpu_hat'] * pred_grid['volume']
    
    return pred_grid

print("✅ Feature engineering functions defined")




import pandas as pd
import numpy as np
import lightgbm as lgb
from datetime import datetime
import joblib
from pathlib import Path
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')

# Configuration parameters
MAX_AGE = 60
WIN = 6      # rolling window
SPAN = 6     # EMA span
START_MONTH = '2025-08'

# Feature columns
FEATURE_COLS = ['cpu_ema6', 'cpu_roll_mean6', 'cpu_roll_std6', 'cpu_pctchg1', 'cpu_lag1']
MODEL_FEATURES = ['age', 'plant', 'model', 'dispatch_month_num',
                  'cpu_ema6', 'cpu_roll_mean6', 'cpu_roll_std6',
                  'cpu_pctchg1', 'cpu_lag1', 'volume']

print("✅ Libraries imported and configuration set")





















def update_master_with_predictions(master_df, pred_grid, forecast_month):
    """Update master dataset with predictions for future feature calculations"""
    if pred_grid.empty:
        return master_df
    
    # Create new rows for master dataset
    new_rows = pred_grid[['plant', 'model', 'dispatch_month', 'age', 'volume', 'cpu_hat']].copy()
    new_rows['cpu'] = new_rows['cpu_hat']  # Use prediction as actual for feature calculation
    new_rows['cost'] = new_rows['cpu_hat'] * new_rows['volume']
    new_rows['claim_month'] = pd.Period(forecast_month, freq='M')
    new_rows = new_rows.drop('cpu_hat', axis=1)
    
    # Append to master dataset
    updated_master = pd.concat([master_df, new_rows], ignore_index=True)
    
    return updated_master

def recalculate_rolling_features_for_cohorts(master_df, affected_cohorts):
    """Recalculate rolling features for specific cohorts"""
    for _, cohort in affected_cohorts.iterrows():
        mask = ((master_df['plant'] == cohort['plant']) & 
               (master_df['model'] == cohort['model']) & 
               (master_df['dispatch_month'] == cohort['dispatch_month']))
        
        if not mask.any():
            continue
            
        cohort_data = master_df[mask].sort_values('age').copy()
        
        # Recalculate rolling features for this cohort
        cohort_data['cpu_ema6'] = cohort_data['cpu'].ewm(span=SPAN, adjust=False).mean()
        cohort_data['cpu_roll_mean6'] = cohort_data['cpu'].rolling(WIN, min_periods=1).mean()
        cohort_data['cpu_roll_std6'] = cohort_data['cpu'].rolling(WIN, min_periods=2).std()
        cohort_data['cpu_lag1'] = cohort_data['cpu'].shift(1)
        cohort_data['cpu_pctchg1'] = cohort_data['cpu'].pct_change()
        
        # Handle infinities
        cohort_data['cpu_pctchg1'].replace([np.inf, -np.inf], np.nan, inplace=True)
        cohort_data[FEATURE_COLS] = cohort_data[FEATURE_COLS].ffill()
        
        # Update master dataset
        master_df.loc[mask, FEATURE_COLS] = cohort_data[FEATURE_COLS].values
    
    return master_df

print("✅ Master dataset update functions defined")



