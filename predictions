def prepare_historical_features(df_hist):
    """Prepare historical data with all rolling features"""
    df = df_hist.copy()
    df['dispatch_month'] = pd.to_datetime(df['dispatch_month']).dt.to_period('M')
    df['cpu'] = df['cost'] / df['volume']
    
    # Calculate rolling features
    grp = df.groupby(['plant', 'model', 'dispatch_month'])
    
    df['cpu_ema6'] = grp['cpu'].apply(lambda s: s.ewm(span=SPAN, adjust=False).mean())
    df['cpu_roll_mean6'] = grp['cpu'].apply(lambda s: s.rolling(WIN, min_periods=1).mean())
    df['cpu_roll_std6'] = grp['cpu'].apply(lambda s: s.rolling(WIN, min_periods=2).std())
    df['cpu_lag1'] = grp['cpu'].shift(1)
    df['cpu_pctchg1'] = grp['cpu'].pct_change()
    
    # Handle infinities and NaNs
    df['cpu_pctchg1'].replace([np.inf, -np.inf], np.nan, inplace=True)
    df[FEATURE_COLS] = df.groupby(['plant', 'model', 'dispatch_month'])[FEATURE_COLS].ffill()
    
    return df

def create_prediction_grid_for_month(master_df, forecast_month):
    """Create prediction grid for a specific forecast month"""
    forecast_period = pd.Period(forecast_month, freq='M')
    cutoff_dispatch = forecast_period - (MAX_AGE - 1)
    
    # Get unique cohorts
    cohorts = (
        master_df.loc[master_df['dispatch_month'].between(cutoff_dispatch, forecast_period)]
        [['plant', 'model', 'dispatch_month', 'volume']].drop_duplicates()
    )
    
    if cohorts.empty:
        return pd.DataFrame()
    
    # Calculate age each cohort will be in forecast month
    cohorts['age'] = (forecast_period - cohorts['dispatch_month']).apply(lambda x: x.n)
    
    # Keep only valid ages (1-60)
    cohorts = cohorts.query('1 <= age <= @MAX_AGE').copy()
    cohorts['forecast_month'] = forecast_period
    cohorts['warranty_month'] = forecast_period
    
    return cohorts

print("âœ… Data preparation functions defined")




def attach_features_to_grid(pred_grid, master_df):
    """Attach rolling features to prediction grid"""
    if pred_grid.empty:
        return pred_grid
    
    # Merge with latest available features
    feature_data = master_df[['plant', 'model', 'dispatch_month', 'age'] + FEATURE_COLS]
    
    pred_grid = pred_grid.merge(
        feature_data,
        on=['plant', 'model', 'dispatch_month', 'age'],
        how='left'
    )
    
    # Forward-fill features within each cohort for missing ages
    pred_grid[FEATURE_COLS] = (
        pred_grid.groupby(['plant', 'model', 'dispatch_month'])[FEATURE_COLS].ffill()
    )
    
    # Add calendar features
    pred_grid['dispatch_month_num'] = pred_grid['dispatch_month'].astype(int)
    
    return pred_grid

def make_predictions(pred_grid, model):
    """Generate CPU and cost predictions"""
    if pred_grid.empty:
        return pred_grid
    
    # Ensure all required features are present
    X = pred_grid[MODEL_FEATURES]
    
    # Predict CPU
    pred_grid['cpu_hat'] = model.predict(X)
    
    # Convert to total cost
    pred_grid['cost_hat'] = pred_grid['cpu_hat'] * pred_grid['volume']
    
    return pred_grid

print("âœ… Feature engineering functions defined")




import pandas as pd
import numpy as np
import lightgbm as lgb
from datetime import datetime
import joblib
from pathlib import Path
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')

# Configuration parameters
MAX_AGE = 60
WIN = 6      # rolling window
SPAN = 6     # EMA span
START_MONTH = '2025-08'

# Feature columns
FEATURE_COLS = ['cpu_ema6', 'cpu_roll_mean6', 'cpu_roll_std6', 'cpu_pctchg1', 'cpu_lag1']
MODEL_FEATURES = ['age', 'plant', 'model', 'dispatch_month_num',
                  'cpu_ema6', 'cpu_roll_mean6', 'cpu_roll_std6',
                  'cpu_pctchg1', 'cpu_lag1', 'volume']

print("âœ… Libraries imported and configuration set")





















def update_master_with_predictions(master_df, pred_grid, forecast_month):
    """Update master dataset with predictions for future feature calculations"""
    if pred_grid.empty:
        return master_df
    
    # Create new rows for master dataset
    new_rows = pred_grid[['plant', 'model', 'dispatch_month', 'age', 'volume', 'cpu_hat']].copy()
    new_rows['cpu'] = new_rows['cpu_hat']  # Use prediction as actual for feature calculation
    new_rows['cost'] = new_rows['cpu_hat'] * new_rows['volume']
    new_rows['claim_month'] = pd.Period(forecast_month, freq='M')
    new_rows = new_rows.drop('cpu_hat', axis=1)
    
    # Append to master dataset
    updated_master = pd.concat([master_df, new_rows], ignore_index=True)
    
    return updated_master

def recalculate_rolling_features_for_cohorts(master_df, affected_cohorts):
    """Recalculate rolling features for specific cohorts"""
    for _, cohort in affected_cohorts.iterrows():
        mask = ((master_df['plant'] == cohort['plant']) & 
               (master_df['model'] == cohort['model']) & 
               (master_df['dispatch_month'] == cohort['dispatch_month']))
        
        if not mask.any():
            continue
            
        cohort_data = master_df[mask].sort_values('age').copy()
        
        # Recalculate rolling features for this cohort
        cohort_data['cpu_ema6'] = cohort_data['cpu'].ewm(span=SPAN, adjust=False).mean()
        cohort_data['cpu_roll_mean6'] = cohort_data['cpu'].rolling(WIN, min_periods=1).mean()
        cohort_data['cpu_roll_std6'] = cohort_data['cpu'].rolling(WIN, min_periods=2).std()
        cohort_data['cpu_lag1'] = cohort_data['cpu'].shift(1)
        cohort_data['cpu_pctchg1'] = cohort_data['cpu'].pct_change()
        
        # Handle infinities
        cohort_data['cpu_pctchg1'].replace([np.inf, -np.inf], np.nan, inplace=True)
        cohort_data[FEATURE_COLS] = cohort_data[FEATURE_COLS].ffill()
        
        # Update master dataset
        master_df.loc[mask, FEATURE_COLS] = cohort_data[FEATURE_COLS].values
    
    return master_df

print("âœ… Master dataset update functions defined")










# SINGLE MONTH PRED 
def predict_single_month(master_df, model, forecast_month):
    """Predict for a single month - useful for testing"""
    print(f"Predicting for {forecast_month}...")
    
    # Create prediction grid
    pred_grid = create_prediction_grid_for_month(master_df, forecast_month)
    
    if pred_grid.empty:
        print(f"  No cohorts to predict for {forecast_month}")
        return pd.DataFrame(), 0
    
    # Attach features and make predictions
    pred_grid = attach_features_to_grid(pred_grid, master_df)
    pred_grid = make_predictions(pred_grid, model)
    
    total_cost = pred_grid['cost_hat'].sum()
    print(f"  Total predicted cost: â‚¹{total_cost:,.0f}")
    print(f"  Number of cohorts: {len(pred_grid)}")
    
    return pred_grid, total_cost

# Test single month prediction
# test_pred, test_cost = predict_single_month(master_df, model, '2025-08')
# print(f"âœ… Single month test completed")





# 60 Mon pred
def forecast_60_months_step_by_step(master_df, model, start_month='2025-08'):
    """Main forecasting function - can be run interactively"""
    
    start_period = pd.Period(start_month, freq='M')
    forecast_results = {}
    current_master = master_df.copy()
    
    print(f"ðŸš€ Starting 60-month forecast from {start_period}")
    print("=" * 60)
    
    for month_offset in range(60):
        current_month = start_period + month_offset
        month_str = str(current_month)
        
        print(f"ðŸ“… Month {month_offset + 1}/60: {current_month}")
        
        # Generate prediction grid
        pred_grid = create_prediction_grid_for_month(current_master, month_str)
        
        if pred_grid.empty:
            print(f"   âš ï¸  No data to predict for {current_month}")
            forecast_results[month_str] = {'total_cost': 0, 'detail': pd.DataFrame()}
            continue
        
        # Attach features and predict
        pred_grid = attach_features_to_grid(pred_grid, current_master)
        pred_grid = make_predictions(pred_grid, model)
        
        # Store results
        total_cost = pred_grid['cost_hat'].sum()
        forecast_results[month_str] = {
            'total_cost': total_cost,
            'detail': pred_grid.copy()
        }
        
        print(f"   ðŸ’° Predicted cost: â‚¹{total_cost:,.0f} ({len(pred_grid)} cohorts)")
        
        # Update master dataset with predictions
        current_master = update_master_with_predictions(current_master, pred_grid, month_str)
        
        # Recalculate rolling features for affected cohorts
        affected_cohorts = pred_grid[['plant', 'model', 'dispatch_month']].drop_duplicates()
        current_master = recalculate_rolling_features_for_cohorts(current_master, affected_cohorts)
        
        # Progress indicator every 10 months
        if (month_offset + 1) % 10 == 0:
            cumulative_cost = sum([r['total_cost'] for r in forecast_results.values()])
            print(f"   ðŸ“Š Cumulative cost after {month_offset + 1} months: â‚¹{cumulative_cost:,.0f}")
            print("-" * 40)
    
    print("âœ… 60-month forecast completed!")
    return forecast_results, current_master

# Run the main forecast
# forecast_results, final_master_df = forecast_60_months_step_by_step(master_df, model, START_MONTH)




# ANALYSIS
def generate_forecast_summary(forecast_results):
    """Generate comprehensive summary from forecast results"""
    
    # Monthly totals
    monthly_data = []
    all_details = []
    
    for month, result in forecast_results.items():
        monthly_data.append({
            'month': month,
            'total_cost': result['total_cost'],
            'num_cohorts': len(result['detail']) if not result['detail'].empty else 0
        })
        
        if not result['detail'].empty:
            detail_copy = result['detail'].copy()
            detail_copy['forecast_month'] = month
            all_details.append(detail_copy)
    
    monthly_summary = pd.DataFrame(monthly_data)
    
    # Combine all details
    if all_details:
        combined_details = pd.concat(all_details, ignore_index=True)
        
        # Plant-wise summary
        plant_summary = combined_details.groupby('plant')['cost_hat'].sum().reset_index()
        plant_summary.columns = ['plant', 'total_cost_60m']
        
        # Model-wise summary
        model_summary = combined_details.groupby(['plant', 'model'])['cost_hat'].sum().reset_index()
        model_summary.columns = ['plant', 'model', 'total_cost_60m']
        
        # Age-wise summary
        age_summary = combined_details.groupby('age')['cost_hat'].sum().reset_index()
        age_summary.columns = ['age', 'total_cost_60m']
        
    else:
        combined_details = pd.DataFrame()
        plant_summary = pd.DataFrame()
        model_summary = pd.DataFrame()
        age_summary = pd.DataFrame()
    
    total_60m_cost = monthly_summary['total_cost'].sum()
    
    return {
        'monthly_summary': monthly_summary,
        'plant_summary': plant_summary,
        'model_summary': model_summary,
        'age_summary': age_summary,
        'combined_details': combined_details,
        'total_60_month_cost': total_60m_cost
    }

# Generate summary
# summary = generate_forecast_summary(forecast_results)
# print(f"ðŸ“ˆ Total 60-month forecast: â‚¹{summary['total_60_month_cost']:,.0f}")




